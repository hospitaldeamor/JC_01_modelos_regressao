---
title: "Journal Club 1: Regress√£o Linear Simples e Regress√£o Log√≠stica Bin√°ria"
subtitle: "Banco de dados: Breast cancer dataset"
author: "LiaaOnco"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 2
editor: 
  markdown: 
    wrap: 72
---

# Introdu√ß√£o

Nesta etapa aula pr√°tica, abordaremos a aplica√ß√£o dos modelo de
regress√£o simples e regress√£o log√≠stica binaria no conjunto de dados
**Breast Cancer Dataset**.<br>

**Fonte**: Wisconsin Diagnostic Breast Cancer (WDBC) dataset <br>
**Dispon√≠vel**: [Kaggle - Breast Cancer
Dataset](https://kaggle.com/datasets/uciml/breast-cancer-wisconsin-data).

## Carregamento de pacotes e dados

```{r, include = FALSE }

## Carregar pacotes 
library(tidyverse)
library(caret)
library(broom)
library(plotly)
library(ggpmisc)
library(pROC)
library(car)
```

```{r}
# Carregar o banco de dados previamente tratado
dados <- read.csv("breast-cancer.csv")

# Transformar a vari√°vel 'diagnosis' em bin√°ria (1 = maligno, 0 = benigno)
dados <- dados %>%
  mutate(diagnosis = ifelse(diagnosis == "M", 1, 0))

```

## Estrutura do banco de dados

```{r}
# Verificar a estrutura dos dados
glimpse(dados)
```

### Vari√°vel dependente (resposta)

'diagnosis': Indica se o n√≥dulo √© maligno ou benigno.<br>

### Vari√°veis independentes (explicativas)

Caracter√≠sticas calculadas a partir da imagem digitalizada de pun√ß√£o
aspirativa por agulha fina (PAAF) de uma massa mam√°ria. <br>

Dez caracter√≠sticas num√©ricas cont√≠nuas foram calculadas para cada
n√∫cleo celular:<br> **a) Radius:** Raio de um n√∫cleo individual,
mensurado pela m√©dia das dist√¢ncias do centro at√© os pontos no
per√≠metro. Quanto maior o raio nuclear, maior a probabilidade de
malignidade celular. <br> **b) Texture:** Desvio padr√£o dos valores de
escala de cinza. Quanto mais heterog√™nea a textura, maior a
probabilidade de malignidade. <br> **c) Perimeter:** Per√≠metro do n√∫cleo
celular. Quanto maior e mais irregular o per√≠metro, maior a
probabilidade de malignidade celular.<br> **d) Area:** √Årea do n√∫cleo
celular. Quanto maior a √°rea, maior a probabilidade de malignidade
celular. <br> **e) Smoothness:** Indica a suavidade do contorno n√∫clear,
medindo a diferen√ßa entre o comprimento do raio nuclear e o comprimento
m√©dio das linhas ao redor. Contornos nucleares mais irregulares indicam
maior probabilidade de malignidade. <br> **f) Compactness:** Indica o
quanto o n√∫cleo est√° compactado. N√∫cleos menos compactos indicam uma
maior probavilidade de malignidade celular.<br> **g) Concavity:**
Gravidade das por√ß√µes c√¥ncavas do contorno. N√∫cleos de maior concavidade
e assimetria s√£o indicativos de malignidade. <br> **h) Concave points:**
N√∫mero de por√ß√µes c√¥ncavas no contorno.<br> **i) Symmetry:** Simetria
nuclear. <br> **j) Fractal dimension:** √â uma medida da complexidade do
contorno do n√∫cleo da c√©lula. Quanto maior a dimens√£o fractal, maior a
probabilidade de malignidade.

Para cada imagem, foram calculados a m√©dia (mean), o erro padr√£o (se) e
o "pior" (worst) valor dessas caracter√≠sticas, resultando em 30
atributos.

## Normaliza√ß√£o dos dados

```{r}
# Normalizar apenas as vari√°veis num√©ricas
dados_normalizados <- dados %>%
  select(-diagnosis) %>%
  scale() %>%
  as.data.frame()

# Adicionar a vari√°vel 'diagnosis' de volta ao banco 
dados_normalizados$diagnosis <- dados$diagnosis

```

## Particionamento dos dados

Dividiremos os dados em dois conjuntos:

-   **Treinamento:** 80% dos dados.
-   **Teste:** 20% dos dados.

```{r}
set.seed(362)

# Criar √≠ndices para o particionamento
train_index <- createDataPartition(dados_normalizados$diagnosis, p = 0.8, list = FALSE)

# Conjuntos de treinamento e teste
train_data <- dados_normalizados[train_index, ]
test_data <- dados_normalizados[-train_index, ]

# Verificar dimens√µes dos conjuntos
dim(train_data)
dim(test_data)
```

```{r}

```

## Regress√£o Linear Simples

**Objetivo**: Predizer o quao heterog√™nea √© a textura do n√∫cleo celular
de acordo com a √°rea.

### Modelagem

```{r}

# Ajuste do modelo
linear_model <- lm(texture_mean ~ area_mean, data = train_data)

# Resumo do modelo
summary(linear_model)

# Previs√£o
linear_preds <- test_data %>%
  mutate(pred = predict(linear_model, newdata = test_data))

# Desempenho
linear_metrics <- linear_preds %>%
  summarise(
    R2 = cor(texture_mean, pred)^2)

linear_metrics


```

### Visualiza√ß√£o

```{r}
ggplot(train_data, aes(x = area_mean, y = texture_mean)) +
  geom_point(color = "darkblue", size = 2, alpha = 0.8) +
  geom_smooth(method = "lm", color = "firebrick", se = TRUE) +
  labs(
    title = "Regress√£o Linear Simples",
    x = "M√©dia da √°rea nuclear",
    y = "M√©dia da textura nuclear"
  ) +
  theme_minimal()

```

## Regress√£o Logistica Bin√°ria

**Objetivo:** Construir um modelo de regress√£o log√≠stica para prever a
probabilidade de um tumor ser maligno (Y=1) com base na m√©dia da
suavidade do contorno nuclear, textura e perimetro nuclear.

### Modelagem

```{r}
# Ajuste do modelo
logistic_model <- glm(diagnosis ~ smoothness_mean + texture_mean + perimeter_mean, 
                      data = train_data, 
                      family = binomial)

# Resumo do modelo
summary(logistic_model)

# Verifica√ß√£o de colinearidade
vif(logistic_model)
```

### Interpreta√ß√£o do coeficiente

Os coeficientes da regress√£o log√≠stica podem ser interpretados como o
impacto das vari√°veis independentes na raz√£o de chance (odds ratio).
<br>

Valores de ùõΩ\> 0 indicam aumento na probabilidade de Y=1 (M), enquanto
valores de Œ≤ \< 0 indicam redu√ß√£o na probabilidade de Y=1 (M).

```{r}
# Calcular odds ratio e intervalos de confian√ßa
exp(cbind(Odds_Ratio = coef(logistic_model), confint(logistic_model)))
```

### Predi√ß√£o e avalia√ß√£o do modelo

```{r}
# Previs√£o
test_data <- test_data %>%
  mutate(predicted_prob = predict(logistic_model, newdata = test_data, type = "response"),
         predicted_class = ifelse(predicted_prob > 0.5, 1, 0))

ggplot(test_data, aes(x = radius_mean, y = diagnosis)) +
  geom_point(alpha = 0.6, color = "darkblue", aes(y = predicted_prob)) +  # Valores previstos
  geom_smooth(method = "glm", method.args = list(family = "binomial"), color = "firebrick") +
  labs(
    title = "Fun√ß√£o Log√≠stica",
    x = "Radius Mean",
    y = "Probabilidade de Malignidade"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14, face = "bold")
  )
```

### Matriz de confus√£o e m√©tricas de avalia√ß√£o

```{r}
# Criar a matriz de confus√£o
conf_matrix <- confusionMatrix(as.factor(test_data$predicted_class), as.factor(test_data$diagnosis))

# Exibir as m√©tricas
conf_matrix
```

### Visualiza√ß√£o

```{r}
# Converter a tabela da matriz de confus√£o para um dataframe
conf_matrix_df <- as.data.frame(conf_matrix$table)

# Plotar a matriz de confus√£o
ggplot(conf_matrix_df, aes(x = Prediction, y = Reference, fill = Freq)) +
  geom_tile(alpha = 0.8) +
  scale_fill_gradient(low = "#cdd3e0", high = "#032263") +
  geom_text(aes(label = Freq), color = "black", size = 6) +
  labs(
    title = "Matriz de Confus√£o",
    x = "Classe Predita",
    y = "Classe Real",
    fill = "Frequ√™ncia"
  ) +
  theme_minimal(base_size = 16) +
  theme(
    plot.title = element_text(hjust = 0.5, size = 18, face = "bold"),
    axis.title = element_text(size = 14, face = "bold")
  )

```

### Curva ROC e AUC

A **curva ROC** mede a capacidade do modelo de distinguir entre classes,
enquanto a **AUC** (√°rea sob a curva) quantifica essa capacidade.

```{r}
# Gerar a curva ROC
roc_curve <- roc(test_data$diagnosis, test_data$predicted_prob)

# Plotar a curva ROC
plot(roc_curve, col = "darkblue", main = "Curva ROC")
abline(a = 0, b = 1, col = "firebrick", lty = 2)

# Exibir o valor da AUC
auc(roc_curve)
```
